{"version":3,"sources":["webpack://real-estate-map/./src/shared/models/api-options.ts","webpack://real-estate-map/./src/ui/index.css?3ef0","webpack://real-estate-map/./src/ui/canvas-overlay.ts","webpack://real-estate-map/./src/ui/heatmap-api-renderer.ts","webpack://real-estate-map/./src/shared/models/point.ts","webpack://real-estate-map/./src/shared/models/tile.ts","webpack://real-estate-map/./src/shared/visible-tiles.ts","webpack://real-estate-map/./src/ui/orchestrator.ts","webpack://real-estate-map/./src/ui/asynchronous.ts","webpack://real-estate-map/./src/ui/renderer.ts","webpack://real-estate-map/./src/ui/index.ts","webpack://real-estate-map/./src/ui/index.css"],"names":["PropertyType","Channel","SortType","CanvasOverlay","google","maps","OverlayView","map","orchestrator","wrapper","createDiv","setMap","this","getPanes","overlayLayer","appendChild","begin","overlayView","getMap","addListener","e","console","log","reset","remove","document","createElement","style","position","HeatmapApiRenderer","url","radius","tileSize","searchOptions","tile","params","JSON","stringify","fetch","createQueryString","response","json","jsonData","Uint8ClampedArray","Object","keys","key","encodeURIComponent","join","pointsEqual","left","right","x","y","generateTileHash","zoom","point","tilesEqual","degreesToPixels","latitude","longitude","sinY","Math","sin","PI","cappedSinY","min","max","degreesToTiles","coordinate","scale","floor","pixelsToTiles","tilesToDegrees","ePi","E","eY","asin","pixelsToDegrees","tilesToPixels","calculateVisibleTiles","coordinateArea","northWest","minX","minY","southEast","maxX","maxY","points","callback","startX","startY","insideX","insideY","callbackCalled","i","spiralLoop","push","generateSpiralCoordinates","BaseOrchestrator","options","subscription","unsubscribed$","Subject","layers","canvases","renderer","initialize","forEach","layer","element","next","unsubscribe","Error","zoom$","observeEvent","pipe","getMapZoom","startWith","bounds$","getMapBounds","visibleTiles$","combineLatest","distinctUntilChanged","auditTime","publishNow","bounds","getVisibleTiles","newTileRenderings$","visibleTiles","filter","every","mergeMap","unrenderedTiles","from","visibleTile","asynchronous","renderTile","isObservable","then","fromPromise","of","image","takeUntil","tiles","repositionLayerSubscription","subscribe","updateLayerPosition","updateTilePositions","createNewTileSubscription","mergeAll","renderedTile","findOrCreateLayer","createAndRenderCanvas","removeTileSubscription","canvas","some","removeCoveredTileSubscription","tileToArea","coveringTile","Subscription","boundsToCoordinateArea","west","north","east","south","id","width","height","find","top","centerPoint","mean","tilePoint","tilePointPixels","centerPointPixels","worldPixelsToLocalPixels","calculateLayerPosition","offset","calculateLayerOffset","assignElementPosition","findLayer","createLayer","undefined","layerPosition","calculateTilePosition","createCanvasElement","updateTilePosition","findCanvas","createCanvas","context","getContext","imageData","createImageData","data","set","putImageData","error","findOrCreateCanvas","renderImageToCanvas","observable","connectable","publish","connect","event","Observable","subscriber","listener","getPlainMap","getZoom","getBounds","toJSON","Map","CachingRenderer","cache","hash","initialSearchSettings","channel","buy","addDomListener","window","getElementById","center","lat","lng","mapTypeId","MapTypeId","TERRAIN","heatmapApiRenderer","cachingRenderer","___CSS_LOADER_EXPORT___","module"],"mappings":"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","file":"main.f38b7e60267a3346e742.js","sourcesContent":["export enum PropertyType {\n  townhouse = 'townhouse',\n  unitApartment = 'unit+apartment',\n  house = 'house',\n  retirement = 'retire',\n  blockOfUnits = 'unitblock',\n  acreage = 'acreage',\n  villa = 'villa',\n}\n\nexport enum Channel {\n  rent = 'rent',\n  buy = 'buy',\n}\n\nexport enum SortType {\n  priceAsc = 'price-asc',\n  priceDesc = 'price-desc',\n}\n\nexport interface ApiOptions {\n  channel: Channel;\n  page?: number;\n  pageSize?: number;\n  suburb?: string;\n  sortType?: SortType;\n  boundingBox?: [number, number, number, number];\n  propertyTypes?: PropertyType[];\n  priceRange?: {\n    minimum?: number;\n    maximum?: number;\n  };\n  bedroomsRange?: {\n    minimum?: number;\n    maximum?: number;\n  };\n  minimumBathrooms?: number;\n  minimumCars?: number;\n}\n","import api from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../node_modules/css-loader/dist/cjs.js!./index.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","import { Orchestrator } from './orchestrator';\n\n// TODO convert all visible tiles functions to use bounds instead of coordinate area\n\nexport class CanvasOverlay extends google.maps.OverlayView {\n  /**\n   * The wrapper div element that will contain the entire overlay.\n   */\n  private readonly wrapper: HTMLElement;\n\n  /**\n   * The orchestrator is responsible for creating and removing tiles and layers.\n   */\n  private readonly orchestrator: Orchestrator;\n\n  constructor(map: google.maps.Map, orchestrator: Orchestrator) {\n    super();\n    this.wrapper = this.createDiv();\n    this.orchestrator = orchestrator;\n\n    // Initializes this overlay for the map and calls `onAdd`\n    this.setMap(map);\n  }\n\n  /**\n   * Called when this overlay is added to a map (when `setMap` is called).\n   */\n  onAdd() {\n    // Overlays are placed in one of a number of panes, here we use the overlay layer to appear\n    // above terrain and other details\n    this.getPanes().overlayLayer.appendChild(this.wrapper);\n    this.orchestrator.begin({\n      overlayView: this,\n      wrapper: this.wrapper,\n    });\n\n    this.getMap().addListener('zoom', (e: any) => console.log('event', e));\n  }\n\n  /**\n   * Called when the overlay should redraw itself.\n   */\n  draw() {\n    // TODO might need to forward these calls to the orchestrator in case there is a way to move the\n    //      map without triggering the drag/zoom handlers.\n  }\n\n  /**\n   * Called when the overlay is removed from a map so that it can clean up resources.\n   */\n  onRemove() {\n    this.orchestrator.reset();\n    this.wrapper.remove();\n  }\n\n  private createDiv(): HTMLElement {\n    const wrapper = document.createElement('div');\n    wrapper.style.position = 'absolute';\n    return wrapper;\n  }\n}\n","import { ApiOptions } from '../shared/models/api-options';\nimport { Tile } from '../shared/models/tile';\nimport { Renderer } from './renderer';\n\nexport class HeatmapApiRenderer implements Renderer {\n  constructor(\n    public url: string,\n    public radius: number,\n    public tileSize: number,\n    public searchOptions: ApiOptions,\n  ) {}\n\n  async renderTile(tile: Tile): Promise<Uint8ClampedArray> {\n    const params: { [k: string]: string } = {\n      searchOptions: JSON.stringify(this.searchOptions), // TODO\n      tile: JSON.stringify(tile),\n      radius: `${this.radius}`,\n      tileSize: `${this.tileSize}`,\n    };\n    const response = await fetch(`${this.url}?${this.createQueryString(params)}`);\n    const jsonData = await response.json();\n    return new Uint8ClampedArray(jsonData);\n  }\n\n  private createQueryString(params: { [k: string]: string }): string {\n    return Object.keys(params).map(key => `${key}=${encodeURIComponent(params[key])}`).join('&');\n  }\n}\n","export interface Point {\n  x: number,\n  y: number,\n}\n\nexport function pointsEqual(left: Point, right: Point) {\n  return left.x === right.x && left.y === right.y;\n}\n","import { Point, pointsEqual } from './point';\n\nexport interface Tile {\n  // Zoom level\n  zoom: number;\n  // Tile coordinates\n  point: Point;\n}\n\nexport function generateTileHash({ zoom, point: { x, y } }: Tile) {\n  return `${zoom}-${x}-${y}`;\n}\n\nexport function tilesEqual(left: Tile, right: Tile) {\n  return left.zoom === right.zoom && pointsEqual(left.point, right.point);\n}\n","import { Coordinates, CoordinateArea } from './models/coordinates';\nimport { Point } from './models/point';\nimport { Tile } from './models/tile';\n\n/**\n * Returns a mercator projection of the coordinates, converting them from degrees to world pixels.\n */\nexport function degreesToPixels(tileSize: number, { latitude, longitude }: Coordinates): Point {\n  const sinY = Math.sin(latitude * Math.PI / 180);\n\n  // Truncating to 0.9999 effectively limits latitude to 89.189. This is\n  // about a third of a tile past the edge of the world tile.\n  const cappedSinY = Math.min(Math.max(sinY, -0.9999), 0.9999);\n\n  return {\n    x: tileSize * (0.5 + longitude / 360),\n    y: tileSize * (0.5 - Math.log((1 + cappedSinY) / (1 - cappedSinY)) / (4 * Math.PI)),\n  };\n}\n\n/**\n * Converts world pixel coordinates to degrees\n */\nexport function pixelsToDegrees(tileSize: number, { x, y }: Point): Coordinates {\n  // Derived from https://www.wolframalpha.com/input/?i=solve+Y%2FT+%3D+0.5+-+(log((1+%2B+L)+%2F+(1+-+L))+%2F+(4%CF%80))+for+L\n  // where L = Math.sin(longitude * Math.PI / 180) and T = tileSize\n  const ePi = Math.E ** (2 * Math.PI);\n  const eY = Math.E ** ((4 * y * Math.PI) / tileSize);\n  const sinY = (ePi - eY) / (ePi + eY);\n  return {\n    latitude: Math.asin(sinY) * 180 / Math.PI,\n    longitude: 360 * (x / tileSize - 0.5),\n  };\n}\n\n/**\n * Converts world pixel coordinates to tile coordinates.\n */\nexport function pixelsToTiles(tileSize: number, zoom: number, { x, y }: Point): Point {\n  const scale = 1 << zoom;\n  return {\n    x: Math.floor(x * scale / tileSize),\n    y: Math.floor(y * scale / tileSize),\n  };\n}\n\n/**\n * Converts tile coordinates to world pixel coordinates.\n */\nexport function tilesToPixels(tileSize: number, zoom: number, { x, y }: Point): Point {\n  const scale = 1 << zoom;\n  return {\n    x: x * tileSize / scale,\n    y: y * tileSize / scale,\n  };\n}\n\n/**\n * Converts a latitude and longitude into tile coordinates at a given zoom level.\n */\nexport function degreesToTiles(tileSize: number, zoom: number, coordinate: Coordinates): Point {\n  return pixelsToTiles(tileSize, zoom, degreesToPixels(tileSize, coordinate));\n}\n\nexport function tilesToDegrees(tileSize: number, zoom: number, point: Point): Coordinates {\n  return pixelsToDegrees(tileSize, tilesToPixels(tileSize, zoom, point));\n}\n\n/**\n * Convert a tile coordinate into local pixel coordinates.\n */\nexport function tileToLocalPixels(tileSize: number, { x, y }: Point): Point {\n  return {\n    x: tileSize * x,\n    y: tileSize * y,\n  };\n}\n\n/**\n * Converts local pixel coordinates to world pixel coordinates.\n */\nexport function localPixelsToWorldPixels(zoom: number, { x, y }: Point): Point {\n  const scale = 1 << zoom;\n  return {\n    x: x / scale,\n    y: y / scale,\n  };\n}\n\nexport function worldPixelsToLocalPixels(zoom: number, { x, y }: Point): Point {\n  const scale = 1 << zoom;\n  return {\n    x: x * scale,\n    y: y * scale,\n  };\n}\n\nexport function degreesToInnerTileCoordinates(\n  tileSize: number,\n  tile: Tile,\n  coordinates: Coordinates,\n): Point {\n  const localTile = tileToLocalPixels(tileSize, tile.point);\n  const localPixels = worldPixelsToLocalPixels(tile.zoom, degreesToPixels(tileSize, coordinates));\n  return {\n    x: localPixels.x - localTile.x,\n    y: localPixels.y - localTile.y,\n  };\n}\n\nexport function spiralLoop(\n  minX: number,\n  maxX: number,\n  minY: number,\n  maxY: number,\n  callback: (x: number, y: number) => any,\n) {\n  const startX = Math.floor((minX + maxX) / 2);\n  const startY = Math.floor((minY + maxY) / 2);\n  const insideX = (x: number) => x >= minX && x <= maxX;\n  const insideY = (y: number) => y >= minY && y <= maxY;\n\n  // Continue to loop in spirals until we go an entire loop without calling the callback\n  let callbackCalled = true;\n  for (let i = 0; callbackCalled; i++) {\n    callbackCalled = false;\n\n    if (insideY(startY - i)) {\n      for (let x = -i; x <= i; x++) {\n        if (insideX(startX + x)) {\n          callbackCalled = true;\n          callback(startX + x, startY - i);\n        }\n      }\n    }\n\n    if (insideX(startX + i)) {\n      for (let y = -i + 1; y <= i; y++) {\n        if (insideY(startY + y)) {\n          callbackCalled = true;\n          callback(startX + i, startY + y);\n        }\n      }\n    }\n\n    if (insideY(startY + i)) {\n      for (let x = i - 1; x >= -i; x--) {\n        if (insideX(startX + x)) {\n          callbackCalled = true;\n          callback(startX + x, startY + i);\n        }\n      }\n    }\n\n    if (insideX(startX - i)) {\n      for (let y = i - 1; y > -i; y--) {\n        if (insideY(startY + y)) {\n          callbackCalled = true;\n          callback(startX - i, startY + y);\n        }\n      }\n    }\n  }\n}\n\nexport function generateSpiralCoordinates(\n  minX: number,\n  maxX: number,\n  minY: number,\n  maxY: number,\n) {\n  const points: Point[] = [];\n  spiralLoop(minX, maxX, minY, maxY, (x, y) => points.push({ x, y }));\n  return points;\n}\n\nexport function calculateVisibleTiles(\n  tileSize: number,\n  zoom: number,\n  coordinateArea: CoordinateArea,\n): Tile[] {\n  // Generate the list of tile coordinates\n  const { x: minX, y: minY } = degreesToTiles(tileSize, zoom, coordinateArea.northWest);\n  const { x: maxX, y: maxY } = degreesToTiles(tileSize, zoom, coordinateArea.southEast);\n  return generateSpiralCoordinates(minX, maxX, minY, maxY).map(point => ({ point, zoom }));\n}\n\nexport function tileToArea(tileSize: number, { zoom, point: { x, y } }: Tile): CoordinateArea {\n  return {\n    northWest: tilesToDegrees(tileSize, zoom, { x, y }),\n    southEast: tilesToDegrees(tileSize, zoom, { x: x + 1, y: y + 1}),\n  };\n}\n\n/**\n * Checks if a coordinate is inside an area.\n * TODO currently has a bug around maximum values of longitude and latitude\n */\nexport function coordinateIsInsideArea(\n  coordinates: Coordinates,\n  area: CoordinateArea,\n): boolean {\n  return coordinates.latitude >= area.southEast.latitude\n    && coordinates.latitude <= area.northWest.latitude\n    && coordinates.longitude >= area.northWest.longitude\n    && coordinates.longitude <= area.southEast.longitude;\n}\n","import { mean } from 'lodash';\nimport {\n  combineLatest,\n  from,\n  MonoTypeOperatorFunction,\n  Observable,\n  Subject,\n  Subscriber,\n  Subscription,\n  TeardownLogic,\n} from 'rxjs';\nimport {\n  auditTime,\n  distinctUntilChanged, filter,\n  map,\n  mergeAll,\n  mergeMap,\n  publish, startWith,\n  takeUntil,\n} from 'rxjs/operators';\nimport { toObservable } from './asynchronous';\nimport { CoordinateArea } from '../shared/models/coordinates';\nimport { Point, pointsEqual } from '../shared/models/point';\nimport { generateTileHash, Tile, tilesEqual } from '../shared/models/tile';\nimport {\n  calculateVisibleTiles,\n  degreesToPixels, tileToArea,\n  tileToLocalPixels,\n  worldPixelsToLocalPixels,\n} from '../shared/visible-tiles';\nimport { Renderer } from './renderer';\nimport MapHandlerMap = google.maps.MapHandlerMap;\n\ninterface Bounds {\n  north: number;\n  south: number;\n  east: number;\n  west: number;\n}\n\ninterface Layer {\n  zoom: number;\n  position: Point;\n  element: HTMLElement;\n}\n\ninterface Canvas {\n  tile: Tile;\n  element: HTMLCanvasElement;\n}\n\nexport interface BeginOrchestratorOptions {\n  overlayView: google.maps.OverlayView;\n  wrapper: HTMLElement;\n}\n\nexport interface Orchestrator {\n  begin(options: BeginOrchestratorOptions): void;\n  reset(): void;\n}\n\nexport interface OrchestratorOptions {\n  tileSize: number;\n  renderer: Renderer;\n}\n\ntype MapEventFirstParameter<N extends keyof MapHandlerMap<any>> = (\n  MapHandlerMap<any>[N] extends (arg: infer T) => any ? T : void\n);\n\nexport class BaseOrchestrator implements Orchestrator {\n  private readonly tileSize: number;\n\n  private readonly renderer: Renderer;\n\n  private wrapper: HTMLElement | null = null;\n\n  private overlayView: google.maps.OverlayView | null = null;\n\n  private subscription: Subscription | null = null;\n\n  private unsubscribed$ = new Subject<void>();\n\n  private layers: Layer[] = [];\n\n  private canvases: Canvas[] = [];\n\n  constructor(options: OrchestratorOptions) {\n    this.tileSize = options.tileSize;\n    this.renderer = options.renderer;\n  }\n\n  begin(options: BeginOrchestratorOptions) {\n    this.overlayView = options.overlayView;\n    this.wrapper = options.wrapper;\n    this.subscription = this.initialize();\n  }\n\n  reset() {\n    this.wrapper = null;\n    this.overlayView = null;\n    this.layers.forEach(layer => layer.element.remove());\n    this.layers = [];\n    this.canvases = [];\n    this.unsubscribed$.next();\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  private initialize(): Subscription {\n    const overlayView = this.overlayView;\n    if (!overlayView) {\n      throw new Error('Could not initialize map. Overlay view was null');\n    }\n\n    const zoom$ = this.observeEvent('zoom_changed').pipe(\n      map(() => this.getMapZoom()),\n      startWith(this.getMapZoom()),\n    );\n\n    const bounds$ = this.observeEvent('bounds_changed').pipe(\n      map(() => this.getMapBounds()),\n      startWith(this.getMapBounds()),\n    );\n\n    // Debounced map position\n    const mapPosition$ = combineLatest([\n      zoom$.pipe(distinctUntilChanged()),\n      bounds$.pipe(distinctUntilChanged()),\n    ]).pipe(\n      // TODO Debounce better. Needs to emit every X seconds with the latest value.\n      auditTime(16),\n      this.publishNow(),\n    );\n\n    // Tile coordinates that need to be rendered\n    const visibleTiles$ = mapPosition$.pipe(\n      map(([zoom, bounds]) => this.getVisibleTiles(zoom, bounds)),\n      this.publishNow(),\n    );\n\n    // Tiles that will need to be added to the view\n    const unrenderedTiles$: Observable<Tile[]> = visibleTiles$.pipe(\n      map(visibleTiles => visibleTiles.filter(tile => (\n        this.canvases.every(({ tile: existingTile }) => !tilesEqual(existingTile, tile))\n      ))),\n      this.publishNow(),\n    );\n\n    // Produce the image data for each tile. This is an observable of individual tiles so that each\n    // one can be emitted as it is ready.\n    const newTileRenderings$: Observable<Observable<{ tile: Tile, image: Uint8ClampedArray }>> = (\n      unrenderedTiles$.pipe(\n        // Convert the array of tiles into an observable of tiles\n        mergeMap(unrenderedTiles => from(unrenderedTiles).pipe(\n          // Map each unrendered tile to an observable with the rendering result\n          map(visibleTile => toObservable(this.renderer.renderTile(visibleTile)).pipe(\n            map(image => ({ image, tile: visibleTile })),\n            // Take each rendered observable until the tile is no longer in vision\n            takeUntil(visibleTiles$.pipe(\n              filter(tiles => tiles.every(tile => !tilesEqual(tile, visibleTile))),\n            )),\n            this.publishNow(),\n          )),\n        )),\n      )\n    );\n\n    const repositionLayerSubscription = this.observeEvent('idle').subscribe(() => {\n      this.layers.forEach((layer) => {\n        if (this.updateLayerPosition(layer)) {\n          this.updateTilePositions(layer);\n        }\n      });\n    });\n\n    const createNewTileSubscription = newTileRenderings$.pipe(\n      mergeAll(),\n    ).subscribe((renderedTile) => {\n      // TODO don't return unneeded variables\n      // Find a layer for it\n      this.findOrCreateLayer(renderedTile.tile.zoom);\n\n      // Create a canvas element\n      this.createAndRenderCanvas(renderedTile);\n    });\n\n    // Removes tiles that are out of vision\n    const removeTileSubscription = visibleTiles$.subscribe((visibleTiles) => {\n      this.canvases = this.canvases.filter((canvas) => {\n        const zoom = this.getMapZoom();\n        if (canvas.tile.zoom === zoom) {\n          if (visibleTiles.some(tile => tilesEqual(canvas.tile, tile))) {\n            return true;\n          }\n        } else {\n          const visibleTilesAtZoom = this.getVisibleTiles(canvas.tile.zoom, this.getMapBounds());\n          if (visibleTilesAtZoom.some(tile => tilesEqual(canvas.tile, tile))) {\n            return true;\n          }\n        }\n\n        canvas.element.remove();\n        return false;\n      });\n    });\n\n    // Removes tiles that have been covered by other tiles\n    const removeCoveredTileSubscription = newTileRenderings$.pipe(\n      mergeAll(),\n    ).subscribe(() => {\n      const zoom = this.getMapZoom();\n      this.canvases = this.canvases.filter((canvas) => {\n        if (canvas.tile.zoom === zoom) {\n          return true;\n        }\n\n        // Find the tiles in the current zoom level required to cover this canvas\n        const coveringTiles = calculateVisibleTiles(\n          this.tileSize,\n          zoom,\n          tileToArea(this.tileSize, canvas.tile),\n        );\n\n        // Check if some of the covering tiles have not been rendered\n        const stillVisible = coveringTiles.some(coveringTile => (\n          !this.canvases.some(canvas => tilesEqual(coveringTile, canvas.tile))\n        ));\n        if (stillVisible) {\n          return true;\n        }\n\n        canvas.element.remove();\n        return false;\n      });\n    });\n\n    // TODO remove tiles\n    // TODO remove layers\n\n    return new Subscription(() => {\n      createNewTileSubscription.unsubscribe();\n      repositionLayerSubscription.unsubscribe();\n      removeTileSubscription.unsubscribe();\n      removeCoveredTileSubscription.unsubscribe();\n    });\n  }\n\n  /**\n   * Returns a list of tiles that are visible within the given bounds.\n   */\n  private getVisibleTiles(zoom: number, bounds: Bounds): Tile[] {\n    return calculateVisibleTiles(this.tileSize, zoom, this.boundsToCoordinateArea(bounds));\n  }\n\n  // TODO remove when the utility functions can accept a bounds directly\n  private boundsToCoordinateArea(bounds: Bounds): CoordinateArea {\n    return {\n      northWest: {\n        longitude: bounds.west,\n        latitude: bounds.north,\n      },\n      southEast: {\n        longitude: bounds.east,\n        latitude: bounds.south,\n      },\n    };\n  }\n\n  private createDiv(): HTMLElement {\n    const wrapper = document.createElement('div');\n    wrapper.style.position = 'absolute';\n    return wrapper;\n  }\n\n  /**\n   * Creates a new canvas element but doesn't attach it to the document.\n   */\n  private createCanvasElement(id: string) {\n    const canvas = document.createElement('canvas');\n    canvas.id = id;\n    canvas.width = this.tileSize;\n    canvas.height = this.tileSize;\n    canvas.style.width = `${this.tileSize}px`;\n    canvas.style.height = `${this.tileSize}px`;\n    canvas.style.position = 'absolute';\n    return canvas;\n  }\n\n  private findLayer(zoom: number): Layer | undefined {\n    return this.layers.find(layer => layer.zoom === zoom);\n  }\n\n  private assignElementPosition(element: HTMLElement, position: Point): void {\n    element.style.left = `${position.x}px`;\n    element.style.top = `${position.y}px`;\n  }\n\n  private calculateLayerPosition(zoom: number): Point {\n    const bounds = this.getMapBounds();\n    // TODO more bugs when crossing over the international date line\n    // Center point of the map in latitude and longitude\n    const centerPoint = {\n      latitude: mean([bounds.north, bounds.south]),\n      longitude: mean([bounds.east, bounds.west]),\n    };\n    // The tile that covers the center point\n    const [centerTile] = calculateVisibleTiles(this.tileSize, zoom, {\n      northWest: centerPoint,\n      southEast: centerPoint,\n    });\n    return centerTile.point;\n  }\n\n  private calculateLayerOffset(zoom: number, tilePoint: Point) {\n    const bounds = this.getMapBounds();\n    // TODO more bugs when crossing over the international date line\n    // Center point of the map in latitude and longitude\n    const centerPoint = {\n      latitude: mean([bounds.north, bounds.south]),\n      longitude: mean([bounds.east, bounds.west]),\n    };\n    // Local pixel coordinates of the top-left corner of the center tile\n    const tilePointPixels = tileToLocalPixels(this.tileSize, tilePoint);\n    // Local pixel coordinates of the center of the map\n    const centerPointPixels = worldPixelsToLocalPixels(\n      zoom,\n      degreesToPixels(this.tileSize, centerPoint),\n    );\n\n    return {\n      x: tilePointPixels.x - centerPointPixels.x,\n      y: tilePointPixels.y - centerPointPixels.y,\n    };\n  }\n\n  private updateLayerPosition(layer: Layer): boolean {\n    const position = this.calculateLayerPosition(layer.zoom);\n    const offset = this.calculateLayerOffset(layer.zoom, position);\n    if (!pointsEqual(offset, layer.position)) {\n      this.assignElementPosition(layer.element, offset);\n      layer.position = position;\n      return true;\n    }\n    return false;\n  }\n\n  private createLayer(zoom: number): Layer {\n    if (!this.wrapper) {\n      throw new Error('Could not create a layer. Wrapper was null');\n    }\n\n    const element = this.createDiv();\n    element.id = `layer-${zoom}`;\n    this.wrapper.appendChild(element);\n\n    const layer = { zoom, element, position: { x: 0, y: 0 } };\n    this.updateLayerPosition(layer);\n    this.layers.push(layer);\n    return layer;\n  }\n\n  private findOrCreateLayer(zoom: number): Layer {\n    return this.findLayer(zoom) || this.createLayer(zoom);\n  }\n\n  private findCanvas(tile: Tile) {\n    const canvas = this.canvases.find(canvas => tilesEqual(tile, canvas.tile));\n    return canvas ? canvas.element : undefined;\n  }\n\n  private calculateTilePosition(tile: Tile, layerPosition: Point) {\n    return {\n      x: (tile.point.x - layerPosition.x) * this.tileSize,\n      y: (tile.point.y - layerPosition.y) * this.tileSize,\n    };\n  }\n\n  private updateTilePosition(tile: Tile, layerPosition: Point, element: HTMLElement) {\n    const position = this.calculateTilePosition(tile, layerPosition);\n    this.assignElementPosition(element, position);\n  }\n\n  private createCanvas(tile: Tile) {\n    const layer = this.findLayer(tile.zoom);\n    if (!layer) {\n      throw new Error(`Could not find layer for zoom ${tile.zoom}`);\n    }\n\n    const element = this.createCanvasElement(generateTileHash(tile));\n    this.updateTilePosition(tile, layer.position, element);\n    layer.element.appendChild(element);\n    this.canvases.push({ tile, element });\n    return element;\n  }\n\n  private findOrCreateCanvas(tile: Tile) {\n    return this.findCanvas(tile) || this.createCanvas(tile);\n  }\n\n  private renderImageToCanvas(image: Uint8ClampedArray, canvas: HTMLCanvasElement) {\n    // Render the image onto the canvas\n    const context = canvas.getContext('2d');\n    if (!context) {\n      console.error('Could not render image to canvas. Context was null');\n      return;\n    }\n\n    const imageData = context.createImageData(this.tileSize, this.tileSize);\n    imageData.data.set(image);\n    context.putImageData(imageData, 0, 0);\n  }\n\n  private createAndRenderCanvas(renderedTile: { image: Uint8ClampedArray, tile: Tile; }) {\n    const canvas = this.findOrCreateCanvas(renderedTile.tile);\n    this.renderImageToCanvas(renderedTile.image, canvas);\n    return canvas;\n  }\n\n  private updateTilePositions(\n    layer: { zoom: number, position: Point, element: HTMLElement; },\n  ): void {\n    this.canvases.forEach((canvas) => {\n      this.updateTilePosition(canvas.tile, layer.position, canvas.element);\n    });\n  }\n\n  /**\n   * Multicasts an observable and connects it immediately. Useful for converting observable chains\n   * from cold to hot. Will automatically clean up the subscriptions when `this.unsubscribe$` emits.\n   */\n  private publishNow<T>(id?: string): MonoTypeOperatorFunction<T> {\n    return (observable) => {\n      const connectable = publish<T>()(observable.pipe(\n        takeUntil(this.unsubscribed$),\n      ));\n\n      // This subscription will be cleaned up when the original observable completes\n      connectable.connect();\n      return connectable;\n    };\n  }\n\n  private observeEvent<N extends keyof MapHandlerMap<any>>(\n    event: N,\n  ): Observable<MapEventFirstParameter<N>> {\n    return new Observable((subscriber: Subscriber<MapEventFirstParameter<N>>): TeardownLogic => {\n      const listener = this.getPlainMap().addListener(event, e => subscriber.next(e));\n      return () => listener.remove();\n    });\n  }\n\n  private getMapZoom(): number {\n    return this.getPlainMap().getZoom();\n  }\n\n  private getMapBounds(): Bounds {\n    const bounds = this.getPlainMap().getBounds();\n    if (!bounds) {\n      throw Error('Invalid bounds');\n    }\n\n    return bounds.toJSON();\n  }\n\n  private getPlainMap(): google.maps.Map {\n    if (!this.overlayView) {\n      throw new Error('Could not retrieve map. Overlay view was null');\n    }\n\n    const map = this.overlayView.getMap();\n    if (!(map instanceof google.maps.Map)) {\n      throw Error('Cannot get the bounds of the map. Map class is incorrect.');\n    }\n    return map;\n  }\n}\n","import { isObservable, Observable, of } from 'rxjs';\nimport { fromPromise } from 'rxjs/internal-compatibility';\n\nexport type Asynchronous<T> = T | Promise<T> | Observable<T>;\n\nexport function toObservable<T>(asynchronous: Asynchronous<T>): Observable<T> {\n  if (isObservable(asynchronous)) {\n    return asynchronous;\n  }\n\n  if (\n    asynchronous\n      && typeof asynchronous === 'object'\n      && typeof (asynchronous as any).then === 'function'\n  ) {\n    return fromPromise(asynchronous as PromiseLike<T>);\n  }\n\n  return of(asynchronous as T);\n}\n","import { Asynchronous } from './asynchronous';\nimport { generateTileHash, Tile } from '../shared/models/tile';\n\nexport interface Renderer {\n  renderTile(tile: Tile): Asynchronous<Uint8ClampedArray>;\n}\n\nexport interface CachingRendererOptions {\n  renderer: Renderer;\n}\n\nexport class CachingRenderer implements Renderer {\n  private renderer: Renderer;\n\n  private cache: { [k: string]: Asynchronous<Uint8ClampedArray> } = {};\n\n  constructor(options: CachingRendererOptions) {\n    this.renderer = options.renderer;\n  }\n\n  renderTile(tile: Tile): Asynchronous<Uint8ClampedArray> {\n    const hash = generateTileHash(tile);\n    if (!(hash in this.cache)) {\n      this.cache[hash] = this.renderer.renderTile(tile);\n    }\n\n    return this.cache[hash];\n  }\n}\n","import './index.css';\nimport { ApiOptions, Channel } from '../shared/models/api-options';\nimport { CanvasOverlay } from './canvas-overlay';\nimport { HeatmapApiRenderer } from './heatmap-api-renderer';\nimport { BaseOrchestrator } from './orchestrator';\nimport { CachingRenderer } from './renderer';\n\nconst TILE_SIZE = 256;\nconst GAUSSIAN_RADIUS = 50;\n\nconst initialSearchSettings: ApiOptions = {\n  channel: Channel.buy,\n  // propertyTypes: [PropertyType.unitApartment],\n  // bedroomsRange: { minimum: 2, maximum: 3 },\n  // minimumBathrooms: 2,\n};\n\ngoogle.maps.event.addDomListener(window, 'load', async () => {\n  const element = document.getElementById('map');\n  if (!element) {\n    throw new Error('Could not find #map element');\n  }\n  const map = new google.maps.Map(element, {\n    zoom: 13,\n    center: { lat: -37.833552, lng: 145.033580 },\n    mapTypeId: google.maps.MapTypeId.TERRAIN,\n  });\n\n  // const propertyLoader = new PropertyLoader(\n  //   TILE_SIZE,\n  //   PROPERTY_BLOCK_ZOOM_LEVEL,\n  //   initialSearchSettings,\n  // );\n  // const heatmapRenderer = new HeatmapRenderer(GAUSSIAN_RADIUS, TILE_SIZE, propertyLoader);\n  const heatmapApiRenderer = new HeatmapApiRenderer(\n    'https://australia-southeast1-real-estate-map-1546133439056.cloudfunctions.net/heatmap-generator',\n    GAUSSIAN_RADIUS,\n    TILE_SIZE,\n    initialSearchSettings,\n  );\n  const cachingRenderer = new CachingRenderer({ renderer: heatmapApiRenderer });\n  const orchestrator = new BaseOrchestrator({\n    renderer: cachingRenderer,\n    tileSize: TILE_SIZE,\n  });\n  new CanvasOverlay(map, orchestrator);\n});\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Optional: Makes the sample page fill the window. */\\nhtml, body {\\n  height: 100%;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/* Always set the map height explicitly to define the size of the div\\n * element that contains the map. */\\n#map {\\n  height: 100%;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/ui/index.css\"],\"names\":[],\"mappings\":\"AAAA,qDAAqD;AACrD;EACE,YAAY;EACZ,SAAS;EACT,UAAU;AACZ;;AAEA;mCACmC;AACnC;EACE,YAAY;AACd\",\"sourcesContent\":[\"/* Optional: Makes the sample page fill the window. */\\nhtml, body {\\n  height: 100%;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/* Always set the map height explicitly to define the size of the div\\n * element that contains the map. */\\n#map {\\n  height: 100%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n"],"sourceRoot":""}