{"version":3,"sources":["webpack://real-estate-map/./src/shared/models/api-options.ts","webpack://real-estate-map/./src/shared/models/point.ts","webpack://real-estate-map/./src/shared/models/tile.ts","webpack://real-estate-map/./src/shared/visible-tiles.ts","webpack://real-estate-map/./src/ui/asynchronous.ts","webpack://real-estate-map/./src/ui/canvas-overlay.ts","webpack://real-estate-map/./src/ui/heatmap-api-renderer.ts","webpack://real-estate-map/./src/ui/index.ts","webpack://real-estate-map/./src/ui/orchestrator.ts","webpack://real-estate-map/./src/ui/renderer.ts","webpack://real-estate-map/./src/ui/index.css","webpack://real-estate-map/./src/ui/index.css?3ef0"],"names":["SortType","Channel","PropertyType","left","right","x","y","zoom","point","pointsEqual","degreesToPixels","tileSize","latitude","longitude","sinY","Math","sin","PI","cappedSinY","min","max","log","pixelsToDegrees","ePi","E","eY","asin","pixelsToTiles","scale","floor","tilesToPixels","degreesToTiles","coordinate","tilesToDegrees","tileToLocalPixels","worldPixelsToLocalPixels","spiralLoop","minX","maxX","minY","maxY","callback","startX","startY","insideX","insideY","callbackCalled","i","generateSpiralCoordinates","points","push","tile","coordinates","localTile","localPixels","coordinateArea","northWest","southEast","map","area","asynchronous","isObservable","then","fromPromise","of","CanvasOverlay","google","maps","OverlayView","orchestrator","wrapper","createDiv","setMap","this","getPanes","overlayLayer","appendChild","begin","overlayView","getMap","addListener","e","console","reset","remove","document","createElement","style","position","HeatmapApiRenderer","url","radius","searchOptions","params","JSON","stringify","fetch","createQueryString","response","json","jsonData","Uint8ClampedArray","Object","keys","key","encodeURIComponent","join","initialSearchSettings","channel","buy","event","addDomListener","window","element","getElementById","Error","Map","center","lat","lng","mapTypeId","MapTypeId","TERRAIN","heatmapApiRenderer","cachingRenderer","CachingRenderer","renderer","BaseOrchestrator","options","subscription","unsubscribed$","Subject","layers","canvases","initialize","forEach","layer","next","unsubscribe","zoom$","observeEvent","pipe","getMapZoom","startWith","bounds$","getMapBounds","visibleTiles$","combineLatest","distinctUntilChanged","auditTime","publishNow","bounds","getVisibleTiles","newTileRenderings$","visibleTiles","filter","every","existingTile","tilesEqual","mergeMap","unrenderedTiles","from","visibleTile","toObservable","renderTile","image","takeUntil","tiles","repositionLayerSubscription","subscribe","updateLayerPosition","updateTilePositions","createNewTileSubscription","mergeAll","renderedTile","findOrCreateLayer","createAndRenderCanvas","removeTileSubscription","canvas","some","removeCoveredTileSubscription","calculateVisibleTiles","tileToArea","coveringTile","Subscription","boundsToCoordinateArea","west","north","east","south","id","width","height","find","top","centerPoint","mean","tilePoint","tilePointPixels","centerPointPixels","calculateLayerPosition","offset","calculateLayerOffset","assignElementPosition","findLayer","createLayer","undefined","layerPosition","calculateTilePosition","createCanvasElement","generateTileHash","updateTilePosition","findCanvas","createCanvas","context","getContext","imageData","createImageData","data","set","putImageData","error","findOrCreateCanvas","renderImageToCanvas","observable","connectable","publish","connect","Observable","subscriber","listener","getPlainMap","getZoom","getBounds","toJSON","cache","hash","___CSS_LOADER_EXPORT___","module"],"mappings":"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","file":"main.a74023827cc5bfadfc16.js","sourcesContent":["export enum PropertyType {\n  townhouse = 'townhouse',\n  unitApartment = 'unit+apartment',\n  house = 'house',\n  retirement = 'retire',\n  blockOfUnits = 'unitblock',\n  acreage = 'acreage',\n  villa = 'villa',\n}\n\nexport enum Channel {\n  rent = 'rent',\n  buy = 'buy',\n}\n\nexport enum SortType {\n  priceAsc = 'price-asc',\n  priceDesc = 'price-desc',\n}\n\nexport interface ApiOptions {\n  channel: Channel;\n  page?: number;\n  pageSize?: number;\n  suburb?: string;\n  sortType?: SortType;\n  boundingBox?: [number, number, number, number];\n  propertyTypes?: PropertyType[];\n  priceRange?: {\n    minimum?: number;\n    maximum?: number;\n  };\n  bedroomsRange?: {\n    minimum?: number;\n    maximum?: number;\n  };\n  minimumBathrooms?: number;\n  minimumCars?: number;\n}\n","export interface Point {\n  x: number,\n  y: number,\n}\n\nexport function pointsEqual(left: Point, right: Point) {\n  return left.x === right.x && left.y === right.y;\n}\n","import { Point, pointsEqual } from './point';\n\nexport interface Tile {\n  // Zoom level\n  zoom: number;\n  // Tile coordinates\n  point: Point;\n}\n\nexport function generateTileHash({ zoom, point: { x, y } }: Tile) {\n  return `${zoom}-${x}-${y}`;\n}\n\nexport function tilesEqual(left: Tile, right: Tile) {\n  return left.zoom === right.zoom && pointsEqual(left.point, right.point);\n}\n","import { Coordinates, CoordinateArea } from './models/coordinates';\nimport { Point } from './models/point';\nimport { Tile } from './models/tile';\n\n/**\n * Returns a mercator projection of the coordinates, converting them from degrees to world pixels.\n */\nexport function degreesToPixels(tileSize: number, { latitude, longitude }: Coordinates): Point {\n  const sinY = Math.sin(latitude * Math.PI / 180);\n\n  // Truncating to 0.9999 effectively limits latitude to 89.189. This is\n  // about a third of a tile past the edge of the world tile.\n  const cappedSinY = Math.min(Math.max(sinY, -0.9999), 0.9999);\n\n  return {\n    x: tileSize * (0.5 + longitude / 360),\n    y: tileSize * (0.5 - Math.log((1 + cappedSinY) / (1 - cappedSinY)) / (4 * Math.PI)),\n  };\n}\n\n/**\n * Converts world pixel coordinates to degrees\n */\nexport function pixelsToDegrees(tileSize: number, { x, y }: Point): Coordinates {\n  // Derived from https://www.wolframalpha.com/input/?i=solve+Y%2FT+%3D+0.5+-+(log((1+%2B+L)+%2F+(1+-+L))+%2F+(4%CF%80))+for+L\n  // where L = Math.sin(longitude * Math.PI / 180) and T = tileSize\n  const ePi = Math.E ** (2 * Math.PI);\n  const eY = Math.E ** ((4 * y * Math.PI) / tileSize);\n  const sinY = (ePi - eY) / (ePi + eY);\n  return {\n    latitude: Math.asin(sinY) * 180 / Math.PI,\n    longitude: 360 * (x / tileSize - 0.5),\n  };\n}\n\n/**\n * Converts world pixel coordinates to tile coordinates.\n */\nexport function pixelsToTiles(tileSize: number, zoom: number, { x, y }: Point): Point {\n  const scale = 1 << zoom;\n  return {\n    x: Math.floor(x * scale / tileSize),\n    y: Math.floor(y * scale / tileSize),\n  };\n}\n\n/**\n * Converts tile coordinates to world pixel coordinates.\n */\nexport function tilesToPixels(tileSize: number, zoom: number, { x, y }: Point): Point {\n  const scale = 1 << zoom;\n  return {\n    x: x * tileSize / scale,\n    y: y * tileSize / scale,\n  };\n}\n\n/**\n * Converts a latitude and longitude into tile coordinates at a given zoom level.\n */\nexport function degreesToTiles(tileSize: number, zoom: number, coordinate: Coordinates): Point {\n  return pixelsToTiles(tileSize, zoom, degreesToPixels(tileSize, coordinate));\n}\n\nexport function tilesToDegrees(tileSize: number, zoom: number, point: Point): Coordinates {\n  return pixelsToDegrees(tileSize, tilesToPixels(tileSize, zoom, point));\n}\n\n/**\n * Convert a tile coordinate into local pixel coordinates.\n */\nexport function tileToLocalPixels(tileSize: number, { x, y }: Point): Point {\n  return {\n    x: tileSize * x,\n    y: tileSize * y,\n  };\n}\n\n/**\n * Converts local pixel coordinates to world pixel coordinates.\n */\nexport function localPixelsToWorldPixels(zoom: number, { x, y }: Point): Point {\n  const scale = 1 << zoom;\n  return {\n    x: x / scale,\n    y: y / scale,\n  };\n}\n\nexport function worldPixelsToLocalPixels(zoom: number, { x, y }: Point): Point {\n  const scale = 1 << zoom;\n  return {\n    x: x * scale,\n    y: y * scale,\n  };\n}\n\nexport function degreesToInnerTileCoordinates(\n  tileSize: number,\n  tile: Tile,\n  coordinates: Coordinates,\n): Point {\n  const localTile = tileToLocalPixels(tileSize, tile.point);\n  const localPixels = worldPixelsToLocalPixels(tile.zoom, degreesToPixels(tileSize, coordinates));\n  return {\n    x: localPixels.x - localTile.x,\n    y: localPixels.y - localTile.y,\n  };\n}\n\nexport function spiralLoop(\n  minX: number,\n  maxX: number,\n  minY: number,\n  maxY: number,\n  callback: (x: number, y: number) => any,\n) {\n  const startX = Math.floor((minX + maxX) / 2);\n  const startY = Math.floor((minY + maxY) / 2);\n  const insideX = (x: number) => x >= minX && x <= maxX;\n  const insideY = (y: number) => y >= minY && y <= maxY;\n\n  // Continue to loop in spirals until we go an entire loop without calling the callback\n  let callbackCalled = true;\n  for (let i = 0; callbackCalled; i++) {\n    callbackCalled = false;\n\n    if (insideY(startY - i)) {\n      for (let x = -i; x <= i; x++) {\n        if (insideX(startX + x)) {\n          callbackCalled = true;\n          callback(startX + x, startY - i);\n        }\n      }\n    }\n\n    if (insideX(startX + i)) {\n      for (let y = -i + 1; y <= i; y++) {\n        if (insideY(startY + y)) {\n          callbackCalled = true;\n          callback(startX + i, startY + y);\n        }\n      }\n    }\n\n    if (insideY(startY + i)) {\n      for (let x = i - 1; x >= -i; x--) {\n        if (insideX(startX + x)) {\n          callbackCalled = true;\n          callback(startX + x, startY + i);\n        }\n      }\n    }\n\n    if (insideX(startX - i)) {\n      for (let y = i - 1; y > -i; y--) {\n        if (insideY(startY + y)) {\n          callbackCalled = true;\n          callback(startX - i, startY + y);\n        }\n      }\n    }\n  }\n}\n\nexport function generateSpiralCoordinates(\n  minX: number,\n  maxX: number,\n  minY: number,\n  maxY: number,\n) {\n  const points: Point[] = [];\n  spiralLoop(minX, maxX, minY, maxY, (x, y) => points.push({ x, y }));\n  return points;\n}\n\nexport function calculateVisibleTiles(\n  tileSize: number,\n  zoom: number,\n  coordinateArea: CoordinateArea,\n): Tile[] {\n  // Generate the list of tile coordinates\n  const { x: minX, y: minY } = degreesToTiles(tileSize, zoom, coordinateArea.northWest);\n  const { x: maxX, y: maxY } = degreesToTiles(tileSize, zoom, coordinateArea.southEast);\n  return generateSpiralCoordinates(minX, maxX, minY, maxY).map(point => ({ point, zoom }));\n}\n\nexport function tileToArea(tileSize: number, { zoom, point: { x, y } }: Tile): CoordinateArea {\n  return {\n    northWest: tilesToDegrees(tileSize, zoom, { x, y }),\n    southEast: tilesToDegrees(tileSize, zoom, { x: x + 1, y: y + 1}),\n  };\n}\n\n/**\n * Checks if a coordinate is inside an area.\n * TODO currently has a bug around maximum values of longitude and latitude\n */\nexport function coordinateIsInsideArea(\n  coordinates: Coordinates,\n  area: CoordinateArea,\n): boolean {\n  return coordinates.latitude >= area.southEast.latitude\n    && coordinates.latitude <= area.northWest.latitude\n    && coordinates.longitude >= area.northWest.longitude\n    && coordinates.longitude <= area.southEast.longitude;\n}\n","import { isObservable, Observable, of } from 'rxjs';\nimport { fromPromise } from 'rxjs/internal-compatibility';\n\nexport type Asynchronous<T> = T | Promise<T> | Observable<T>;\n\nexport function toObservable<T>(asynchronous: Asynchronous<T>): Observable<T> {\n  if (isObservable(asynchronous)) {\n    return asynchronous;\n  }\n\n  if (\n    asynchronous\n      && typeof asynchronous === 'object'\n      && typeof (asynchronous as any).then === 'function'\n  ) {\n    return fromPromise(asynchronous as PromiseLike<T>);\n  }\n\n  return of(asynchronous as T);\n}\n","import { Orchestrator } from './orchestrator';\n\n// TODO convert all visible tiles functions to use bounds instead of coordinate area\n\nexport class CanvasOverlay extends google.maps.OverlayView {\n  /**\n   * The wrapper div element that will contain the entire overlay.\n   */\n  private readonly wrapper: HTMLElement;\n\n  /**\n   * The orchestrator is responsible for creating and removing tiles and layers.\n   */\n  private readonly orchestrator: Orchestrator;\n\n  constructor(map: google.maps.Map, orchestrator: Orchestrator) {\n    super();\n    this.wrapper = this.createDiv();\n    this.orchestrator = orchestrator;\n\n    // Initializes this overlay for the map and calls `onAdd`\n    this.setMap(map);\n  }\n\n  /**\n   * Called when this overlay is added to a map (when `setMap` is called).\n   */\n  onAdd() {\n    // Overlays are placed in one of a number of panes, here we use the overlay layer to appear\n    // above terrain and other details\n    this.getPanes().overlayLayer.appendChild(this.wrapper);\n    this.orchestrator.begin({\n      overlayView: this,\n      wrapper: this.wrapper,\n    });\n\n    this.getMap().addListener('zoom', (e: any) => console.log('event', e));\n  }\n\n  /**\n   * Called when the overlay should redraw itself.\n   */\n  draw() {\n    // TODO might need to forward these calls to the orchestrator in case there is a way to move the\n    //      map without triggering the drag/zoom handlers.\n  }\n\n  /**\n   * Called when the overlay is removed from a map so that it can clean up resources.\n   */\n  onRemove() {\n    this.orchestrator.reset();\n    this.wrapper.remove();\n  }\n\n  private createDiv(): HTMLElement {\n    const wrapper = document.createElement('div');\n    wrapper.style.position = 'absolute';\n    return wrapper;\n  }\n}\n","import { ApiOptions } from '../shared/models/api-options';\nimport { Tile } from '../shared/models/tile';\nimport { Renderer } from './renderer';\n\nexport class HeatmapApiRenderer implements Renderer {\n  constructor(\n    public url: string,\n    public radius: number,\n    public tileSize: number,\n    public searchOptions: ApiOptions,\n  ) {}\n\n  async renderTile(tile: Tile): Promise<Uint8ClampedArray> {\n    const params: { [k: string]: string } = {\n      searchOptions: JSON.stringify(this.searchOptions), // TODO\n      tile: JSON.stringify(tile),\n      radius: `${this.radius}`,\n      tileSize: `${this.tileSize}`,\n    };\n    const response = await fetch(`${this.url}?${this.createQueryString(params)}`);\n    const jsonData = await response.json();\n    return new Uint8ClampedArray(jsonData);\n  }\n\n  private createQueryString(params: { [k: string]: string }): string {\n    return Object.keys(params).map(key => `${key}=${encodeURIComponent(params[key])}`).join('&');\n  }\n}\n","import './index.css';\nimport { ApiOptions, Channel } from '../shared/models/api-options';\nimport { CanvasOverlay } from './canvas-overlay';\nimport { HeatmapApiRenderer } from './heatmap-api-renderer';\nimport { BaseOrchestrator } from './orchestrator';\nimport { CachingRenderer } from './renderer';\n\nconst TILE_SIZE = 256;\nconst GAUSSIAN_RADIUS = 50;\n\nconst initialSearchSettings: ApiOptions = {\n  channel: Channel.buy,\n  // propertyTypes: [PropertyType.unitApartment],\n  // bedroomsRange: { minimum: 2, maximum: 3 },\n  // minimumBathrooms: 2,\n};\n\ngoogle.maps.event.addDomListener(window, 'load', async () => {\n  const element = document.getElementById('map');\n  if (!element) {\n    throw new Error('Could not find #map element');\n  }\n  const map = new google.maps.Map(element, {\n    zoom: 13,\n    center: { lat: -37.833552, lng: 145.033580 },\n    mapTypeId: google.maps.MapTypeId.TERRAIN,\n  });\n\n  // const propertyLoader = new PropertyLoader(\n  //   TILE_SIZE,\n  //   PROPERTY_BLOCK_ZOOM_LEVEL,\n  //   initialSearchSettings,\n  // );\n  // const heatmapRenderer = new HeatmapRenderer(GAUSSIAN_RADIUS, TILE_SIZE, propertyLoader);\n  const heatmapApiRenderer = new HeatmapApiRenderer(\n    'https://australia-southeast1-real-estate-map-1546133439056.cloudfunctions.net/heatmap-generator',\n    GAUSSIAN_RADIUS,\n    TILE_SIZE,\n    initialSearchSettings,\n  );\n  const cachingRenderer = new CachingRenderer({ renderer: heatmapApiRenderer });\n  const orchestrator = new BaseOrchestrator({\n    renderer: cachingRenderer,\n    tileSize: TILE_SIZE,\n  });\n  new CanvasOverlay(map, orchestrator);\n});\n","import { mean } from 'lodash';\nimport {\n  combineLatest,\n  from,\n  MonoTypeOperatorFunction,\n  Observable,\n  Subject,\n  Subscriber,\n  Subscription,\n  TeardownLogic,\n} from 'rxjs';\nimport {\n  auditTime,\n  distinctUntilChanged, filter,\n  map,\n  mergeAll,\n  mergeMap,\n  publish, startWith,\n  takeUntil,\n} from 'rxjs/operators';\nimport { toObservable } from './asynchronous';\nimport { CoordinateArea } from '../shared/models/coordinates';\nimport { Point, pointsEqual } from '../shared/models/point';\nimport { generateTileHash, Tile, tilesEqual } from '../shared/models/tile';\nimport {\n  calculateVisibleTiles,\n  degreesToPixels, tileToArea,\n  tileToLocalPixels,\n  worldPixelsToLocalPixels,\n} from '../shared/visible-tiles';\nimport { Renderer } from './renderer';\nimport MapHandlerMap = google.maps.MapHandlerMap;\n\ninterface Bounds {\n  north: number;\n  south: number;\n  east: number;\n  west: number;\n}\n\ninterface Layer {\n  zoom: number;\n  position: Point;\n  element: HTMLElement;\n}\n\ninterface Canvas {\n  tile: Tile;\n  element: HTMLCanvasElement;\n}\n\nexport interface BeginOrchestratorOptions {\n  overlayView: google.maps.OverlayView;\n  wrapper: HTMLElement;\n}\n\nexport interface Orchestrator {\n  begin(options: BeginOrchestratorOptions): void;\n  reset(): void;\n}\n\nexport interface OrchestratorOptions {\n  tileSize: number;\n  renderer: Renderer;\n}\n\ntype MapEventFirstParameter<N extends keyof MapHandlerMap<any>> = (\n  MapHandlerMap<any>[N] extends (arg: infer T) => any ? T : void\n);\n\nexport class BaseOrchestrator implements Orchestrator {\n  private readonly tileSize: number;\n\n  private readonly renderer: Renderer;\n\n  private wrapper: HTMLElement | null = null;\n\n  private overlayView: google.maps.OverlayView | null = null;\n\n  private subscription: Subscription | null = null;\n\n  private unsubscribed$ = new Subject<void>();\n\n  private layers: Layer[] = [];\n\n  private canvases: Canvas[] = [];\n\n  constructor(options: OrchestratorOptions) {\n    this.tileSize = options.tileSize;\n    this.renderer = options.renderer;\n  }\n\n  begin(options: BeginOrchestratorOptions) {\n    this.overlayView = options.overlayView;\n    this.wrapper = options.wrapper;\n    this.subscription = this.initialize();\n  }\n\n  reset() {\n    this.wrapper = null;\n    this.overlayView = null;\n    this.layers.forEach(layer => layer.element.remove());\n    this.layers = [];\n    this.canvases = [];\n    this.unsubscribed$.next();\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n\n  private initialize(): Subscription {\n    const overlayView = this.overlayView;\n    if (!overlayView) {\n      throw new Error('Could not initialize map. Overlay view was null');\n    }\n\n    const zoom$ = this.observeEvent('zoom_changed').pipe(\n      map(() => this.getMapZoom()),\n      startWith(this.getMapZoom()),\n    );\n\n    const bounds$ = this.observeEvent('bounds_changed').pipe(\n      map(() => this.getMapBounds()),\n      startWith(this.getMapBounds()),\n    );\n\n    // Debounced map position\n    const mapPosition$ = combineLatest([\n      zoom$.pipe(distinctUntilChanged()),\n      bounds$.pipe(distinctUntilChanged()),\n    ]).pipe(\n      // TODO Debounce better. Needs to emit every X seconds with the latest value.\n      auditTime(16),\n      this.publishNow(),\n    );\n\n    // Tile coordinates that need to be rendered\n    const visibleTiles$ = mapPosition$.pipe(\n      map(([zoom, bounds]) => this.getVisibleTiles(zoom, bounds)),\n      this.publishNow(),\n    );\n\n    // Tiles that will need to be added to the view\n    const unrenderedTiles$: Observable<Tile[]> = visibleTiles$.pipe(\n      map(visibleTiles => visibleTiles.filter(tile => (\n        this.canvases.every(({ tile: existingTile }) => !tilesEqual(existingTile, tile))\n      ))),\n      this.publishNow(),\n    );\n\n    // Produce the image data for each tile. This is an observable of individual tiles so that each\n    // one can be emitted as it is ready.\n    const newTileRenderings$: Observable<Observable<{ tile: Tile, image: Uint8ClampedArray }>> = (\n      unrenderedTiles$.pipe(\n        // Convert the array of tiles into an observable of tiles\n        mergeMap(unrenderedTiles => from(unrenderedTiles).pipe(\n          // Map each unrendered tile to an observable with the rendering result\n          map(visibleTile => toObservable(this.renderer.renderTile(visibleTile)).pipe(\n            map(image => ({ image, tile: visibleTile })),\n            // Take each rendered observable until the tile is no longer in vision\n            takeUntil(visibleTiles$.pipe(\n              filter(tiles => tiles.every(tile => !tilesEqual(tile, visibleTile))),\n            )),\n            this.publishNow(),\n          )),\n        )),\n      )\n    );\n\n    const repositionLayerSubscription = this.observeEvent('idle').subscribe(() => {\n      this.layers.forEach((layer) => {\n        if (this.updateLayerPosition(layer)) {\n          this.updateTilePositions(layer);\n        }\n      });\n    });\n\n    const createNewTileSubscription = newTileRenderings$.pipe(\n      mergeAll(),\n    ).subscribe((renderedTile) => {\n      // TODO don't return unneeded variables\n      // Find a layer for it\n      this.findOrCreateLayer(renderedTile.tile.zoom);\n\n      // Create a canvas element\n      this.createAndRenderCanvas(renderedTile);\n    });\n\n    // Removes tiles that are out of vision\n    const removeTileSubscription = visibleTiles$.subscribe((visibleTiles) => {\n      this.canvases = this.canvases.filter((canvas) => {\n        const zoom = this.getMapZoom();\n        if (canvas.tile.zoom === zoom) {\n          if (visibleTiles.some(tile => tilesEqual(canvas.tile, tile))) {\n            return true;\n          }\n        } else {\n          const visibleTilesAtZoom = this.getVisibleTiles(canvas.tile.zoom, this.getMapBounds());\n          if (visibleTilesAtZoom.some(tile => tilesEqual(canvas.tile, tile))) {\n            return true;\n          }\n        }\n\n        canvas.element.remove();\n        return false;\n      });\n    });\n\n    // Removes tiles that have been covered by other tiles\n    const removeCoveredTileSubscription = newTileRenderings$.pipe(\n      mergeAll(),\n    ).subscribe(() => {\n      const zoom = this.getMapZoom();\n      this.canvases = this.canvases.filter((canvas) => {\n        if (canvas.tile.zoom === zoom) {\n          return true;\n        }\n\n        // Find the tiles in the current zoom level required to cover this canvas\n        const coveringTiles = calculateVisibleTiles(\n          this.tileSize,\n          zoom,\n          tileToArea(this.tileSize, canvas.tile),\n        );\n\n        // Check if some of the covering tiles have not been rendered\n        const stillVisible = coveringTiles.some(coveringTile => (\n          !this.canvases.some(canvas => tilesEqual(coveringTile, canvas.tile))\n        ));\n        if (stillVisible) {\n          return true;\n        }\n\n        canvas.element.remove();\n        return false;\n      });\n    });\n\n    // TODO remove tiles\n    // TODO remove layers\n\n    return new Subscription(() => {\n      createNewTileSubscription.unsubscribe();\n      repositionLayerSubscription.unsubscribe();\n      removeTileSubscription.unsubscribe();\n      removeCoveredTileSubscription.unsubscribe();\n    });\n  }\n\n  /**\n   * Returns a list of tiles that are visible within the given bounds.\n   */\n  private getVisibleTiles(zoom: number, bounds: Bounds): Tile[] {\n    return calculateVisibleTiles(this.tileSize, zoom, this.boundsToCoordinateArea(bounds));\n  }\n\n  // TODO remove when the utility functions can accept a bounds directly\n  private boundsToCoordinateArea(bounds: Bounds): CoordinateArea {\n    return {\n      northWest: {\n        longitude: bounds.west,\n        latitude: bounds.north,\n      },\n      southEast: {\n        longitude: bounds.east,\n        latitude: bounds.south,\n      },\n    };\n  }\n\n  private createDiv(): HTMLElement {\n    const wrapper = document.createElement('div');\n    wrapper.style.position = 'absolute';\n    return wrapper;\n  }\n\n  /**\n   * Creates a new canvas element but doesn't attach it to the document.\n   */\n  private createCanvasElement(id: string) {\n    const canvas = document.createElement('canvas');\n    canvas.id = id;\n    canvas.width = this.tileSize;\n    canvas.height = this.tileSize;\n    canvas.style.width = `${this.tileSize}px`;\n    canvas.style.height = `${this.tileSize}px`;\n    canvas.style.position = 'absolute';\n    return canvas;\n  }\n\n  private findLayer(zoom: number): Layer | undefined {\n    return this.layers.find(layer => layer.zoom === zoom);\n  }\n\n  private assignElementPosition(element: HTMLElement, position: Point): void {\n    element.style.left = `${position.x}px`;\n    element.style.top = `${position.y}px`;\n  }\n\n  private calculateLayerPosition(zoom: number): Point {\n    const bounds = this.getMapBounds();\n    // TODO more bugs when crossing over the international date line\n    // Center point of the map in latitude and longitude\n    const centerPoint = {\n      latitude: mean([bounds.north, bounds.south]),\n      longitude: mean([bounds.east, bounds.west]),\n    };\n    // The tile that covers the center point\n    const [centerTile] = calculateVisibleTiles(this.tileSize, zoom, {\n      northWest: centerPoint,\n      southEast: centerPoint,\n    });\n    return centerTile.point;\n  }\n\n  private calculateLayerOffset(zoom: number, tilePoint: Point) {\n    const bounds = this.getMapBounds();\n    // TODO more bugs when crossing over the international date line\n    // Center point of the map in latitude and longitude\n    const centerPoint = {\n      latitude: mean([bounds.north, bounds.south]),\n      longitude: mean([bounds.east, bounds.west]),\n    };\n    // Local pixel coordinates of the top-left corner of the center tile\n    const tilePointPixels = tileToLocalPixels(this.tileSize, tilePoint);\n    // Local pixel coordinates of the center of the map\n    const centerPointPixels = worldPixelsToLocalPixels(\n      zoom,\n      degreesToPixels(this.tileSize, centerPoint),\n    );\n\n    return {\n      x: tilePointPixels.x - centerPointPixels.x,\n      y: tilePointPixels.y - centerPointPixels.y,\n    };\n  }\n\n  private updateLayerPosition(layer: Layer): boolean {\n    const position = this.calculateLayerPosition(layer.zoom);\n    const offset = this.calculateLayerOffset(layer.zoom, position);\n    if (!pointsEqual(offset, layer.position)) {\n      this.assignElementPosition(layer.element, offset);\n      layer.position = position;\n      return true;\n    }\n    return false;\n  }\n\n  private createLayer(zoom: number): Layer {\n    if (!this.wrapper) {\n      throw new Error('Could not create a layer. Wrapper was null');\n    }\n\n    const element = this.createDiv();\n    element.id = `layer-${zoom}`;\n    this.wrapper.appendChild(element);\n\n    const layer = { zoom, element, position: { x: 0, y: 0 } };\n    this.updateLayerPosition(layer);\n    this.layers.push(layer);\n    return layer;\n  }\n\n  private findOrCreateLayer(zoom: number): Layer {\n    return this.findLayer(zoom) || this.createLayer(zoom);\n  }\n\n  private findCanvas(tile: Tile) {\n    const canvas = this.canvases.find(canvas => tilesEqual(tile, canvas.tile));\n    return canvas ? canvas.element : undefined;\n  }\n\n  private calculateTilePosition(tile: Tile, layerPosition: Point) {\n    return {\n      x: (tile.point.x - layerPosition.x) * this.tileSize,\n      y: (tile.point.y - layerPosition.y) * this.tileSize,\n    };\n  }\n\n  private updateTilePosition(tile: Tile, layerPosition: Point, element: HTMLElement) {\n    const position = this.calculateTilePosition(tile, layerPosition);\n    this.assignElementPosition(element, position);\n  }\n\n  private createCanvas(tile: Tile) {\n    const layer = this.findLayer(tile.zoom);\n    if (!layer) {\n      throw new Error(`Could not find layer for zoom ${tile.zoom}`);\n    }\n\n    const element = this.createCanvasElement(generateTileHash(tile));\n    this.updateTilePosition(tile, layer.position, element);\n    layer.element.appendChild(element);\n    this.canvases.push({ tile, element });\n    return element;\n  }\n\n  private findOrCreateCanvas(tile: Tile) {\n    return this.findCanvas(tile) || this.createCanvas(tile);\n  }\n\n  private renderImageToCanvas(image: Uint8ClampedArray, canvas: HTMLCanvasElement) {\n    // Render the image onto the canvas\n    const context = canvas.getContext('2d');\n    if (!context) {\n      console.error('Could not render image to canvas. Context was null');\n      return;\n    }\n\n    const imageData = context.createImageData(this.tileSize, this.tileSize);\n    imageData.data.set(image);\n    context.putImageData(imageData, 0, 0);\n  }\n\n  private createAndRenderCanvas(renderedTile: { image: Uint8ClampedArray, tile: Tile; }) {\n    const canvas = this.findOrCreateCanvas(renderedTile.tile);\n    this.renderImageToCanvas(renderedTile.image, canvas);\n    return canvas;\n  }\n\n  private updateTilePositions(\n    layer: { zoom: number, position: Point, element: HTMLElement; },\n  ): void {\n    this.canvases.forEach((canvas) => {\n      this.updateTilePosition(canvas.tile, layer.position, canvas.element);\n    });\n  }\n\n  /**\n   * Multicasts an observable and connects it immediately. Useful for converting observable chains\n   * from cold to hot. Will automatically clean up the subscriptions when `this.unsubscribe$` emits.\n   */\n  private publishNow<T>(id?: string): MonoTypeOperatorFunction<T> {\n    return (observable) => {\n      const connectable = publish<T>()(observable.pipe(\n        takeUntil(this.unsubscribed$),\n      ));\n\n      // This subscription will be cleaned up when the original observable completes\n      connectable.connect();\n      return connectable;\n    };\n  }\n\n  private observeEvent<N extends keyof MapHandlerMap<any>>(\n    event: N,\n  ): Observable<MapEventFirstParameter<N>> {\n    return new Observable((subscriber: Subscriber<MapEventFirstParameter<N>>): TeardownLogic => {\n      const listener = this.getPlainMap().addListener(event, e => subscriber.next(e));\n      return () => listener.remove();\n    });\n  }\n\n  private getMapZoom(): number {\n    return this.getPlainMap().getZoom();\n  }\n\n  private getMapBounds(): Bounds {\n    const bounds = this.getPlainMap().getBounds();\n    if (!bounds) {\n      throw Error('Invalid bounds');\n    }\n\n    return bounds.toJSON();\n  }\n\n  private getPlainMap(): google.maps.Map {\n    if (!this.overlayView) {\n      throw new Error('Could not retrieve map. Overlay view was null');\n    }\n\n    const map = this.overlayView.getMap();\n    if (!(map instanceof google.maps.Map)) {\n      throw Error('Cannot get the bounds of the map. Map class is incorrect.');\n    }\n    return map;\n  }\n}\n","import { Asynchronous } from './asynchronous';\nimport { generateTileHash, Tile } from '../shared/models/tile';\n\nexport interface Renderer {\n  renderTile(tile: Tile): Asynchronous<Uint8ClampedArray>;\n}\n\nexport interface CachingRendererOptions {\n  renderer: Renderer;\n}\n\nexport class CachingRenderer implements Renderer {\n  private renderer: Renderer;\n\n  private cache: { [k: string]: Asynchronous<Uint8ClampedArray> } = {};\n\n  constructor(options: CachingRendererOptions) {\n    this.renderer = options.renderer;\n  }\n\n  renderTile(tile: Tile): Asynchronous<Uint8ClampedArray> {\n    const hash = generateTileHash(tile);\n    if (!(hash in this.cache)) {\n      this.cache[hash] = this.renderer.renderTile(tile);\n    }\n\n    return this.cache[hash];\n  }\n}\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Optional: Makes the sample page fill the window. */\\nhtml, body {\\n  height: 100%;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/* Always set the map height explicitly to define the size of the div\\n * element that contains the map. */\\n#map {\\n  height: 100%;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/ui/index.css\"],\"names\":[],\"mappings\":\"AAAA,qDAAqD;AACrD;EACE,YAAY;EACZ,SAAS;EACT,UAAU;AACZ;;AAEA;mCACmC;AACnC;EACE,YAAY;AACd\",\"sourcesContent\":[\"/* Optional: Makes the sample page fill the window. */\\nhtml, body {\\n  height: 100%;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/* Always set the map height explicitly to define the size of the div\\n * element that contains the map. */\\n#map {\\n  height: 100%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","import api from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../node_modules/css-loader/dist/cjs.js!./index.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};"],"sourceRoot":""}